#pragma once

#include "roxy/core/types.hpp"

// IL Opcode list for the Roxy language.

#define OPCODE_LIST(X)      \
    X(Nop)                  \
    X(Break)                \
    X(Ld_Arg_0)             \
    X(Ld_Arg_1)             \
    X(Ld_Arg_2)             \
    X(Ld_Arg_3)             \
    X(Ld_Loc_0)             \
    X(Ld_Loc_1)             \
    X(Ld_Loc_2)             \
    X(Ld_Loc_3)             \
    X(St_Loc_0)             \
    X(St_Loc_1)             \
    X(St_Loc_2)             \
    X(St_Loc_3)             \
    X(Ld_Arg_S)             \
    X(St_Arg_S)             \
    X(Ld_Loc)               \
    X(Ld_Loc_S)             \
    X(St_Loc)               \
    X(St_Loc_S)             \
    X(Ld_Arg_i8_0)          \
    X(Ld_Arg_i8_1)          \
    X(Ld_Arg_i8_2)          \
    X(Ld_Arg_i8_3)          \
    X(Ld_Loc_i8_0)          \
    X(Ld_Loc_i8_1)          \
    X(Ld_Loc_i8_2)          \
    X(Ld_Loc_i8_3)          \
    X(St_Loc_i8_0)          \
    X(St_Loc_i8_1)          \
    X(St_Loc_i8_2)          \
    X(St_Loc_i8_3)          \
    X(Ld_Arg_i8_S)          \
    X(St_Arg_i8_S)          \
    X(Ld_Loc_i8)            \
    X(Ld_Loc_i8_S)          \
    X(St_Loc_i8)            \
    X(St_Loc_i8_S)          \
    X(LdC_Null)             \
    X(LdC_i4_M1)            \
    X(LdC_i4_0)             \
    X(LdC_i4_1)             \
    X(LdC_i4_2)             \
    X(LdC_i4_3)             \
    X(LdC_i4_4)             \
    X(LdC_i4_5)             \
    X(LdC_i4_6)             \
    X(LdC_i4_7)             \
    X(LdC_i4_8)             \
    X(LdC_i4_S)             \
    X(LdC_i4)                \
    X(LdC_i8)                \
    X(LdC_r4)                \
    X(LdC_r8)                \
    X(Dup)                  \
    X(Pop)                  \
    X(Jmp)                  \
    X(Call)                 \
    X(CallI)                \
    X(Ret)                  \
    X(Br_S)                 \
    X(BrFalse_S)            \
    X(BrTrue_S)             \
    X(BrEq_S)               \
    X(BrGe_S)               \
    X(BrGt_S)               \
    X(BrLe_S)               \
    X(BrLt_S)               \
    X(BrNe_UnS)             \
    X(BrGe_UnS)             \
    X(BrGt_UnS)             \
    X(BrLe_UnS)             \
    X(BrLt_UnS)             \
    X(Br)                   \
    X(BrFalse)              \
    X(BrTrue)               \
    X(BrEq)                 \
    X(BrGe)                 \
    X(BrGt)                 \
    X(BrLe)                 \
    X(BrLt)                 \
    X(BrEq_Un)              \
    X(BrGe_Un)              \
    X(BrGt_Un)              \
    X(BrLe_Un)              \
    X(BrLt_Un)              \
    X(Switch)               \
    X(LdInd_i1)             \
    X(LdInd_u1)             \
    X(LdInd_i2)             \
    X(LdInd_u2)             \
    X(LdInd_i4)             \
    X(LdInd_u4)             \
    X(LdInd_i8)             \
    X(LdInd_u8)             \
    X(LdInd_r4)             \
    X(LdInd_r8)             \
    X(LdInd_ref)            \
    X(StInd_ref)            \
    X(StInd_i1)             \
    X(StInd_i2)             \
    X(StInd_i4)             \
    X(StInd_i8)             \
    X(StInd_r4)             \
    X(StInd_r8)             \
    X(Add_i4)               \
    X(Sub_i4)               \
    X(Mul_i4)               \
    X(Mul_u4)               \
    X(Div_i4)               \
    X(Div_u4)               \
    X(Rem_i4)               \
    X(Rem_u4)               \
    X(Add_i8)               \
    X(Sub_i8)               \
    X(Mul_i8)               \
    X(Mul_u8)               \
    X(Div_i8)               \
    X(Div_u8)               \
    X(Rem_i8)               \
    X(Rem_u8)               \
    X(Add_r4)               \
    X(Sub_r4)               \
    X(Mul_r4)               \
    X(Div_r4)               \
    X(Add_r8)               \
    X(Sub_r8)               \
    X(Mul_r8)               \
    X(Div_r8)               \
    X(And)                  \
    X(Or)                   \
    X(Xor)                  \
    X(Shl)                  \
    X(Shr)                  \
    X(Shr_Un)               \
    X(Neg)                  \
    X(Not)                  \
    X(Conv_i1)              \
    X(Conv_u1)              \
    X(Conv_i2)              \
    X(Conv_u2)              \
    X(Conv_i4)              \
    X(Conv_u4)              \
    X(Conv_i8)              \
    X(Conv_u8)              \
    X(Conv_r4)              \
    X(Conv_r8)              \
    X(CpObj)                \
    X(LdObj)                \
    X(LdStr)                \
    X(NewObj)               \
    X(CastClass)            \
    X(Unbox)                \
    X(Throw)                \
    X(LdFld)                \
    X(LdFldA)               \
    X(StFld)                \
    X(StObj)                \
    X(Box)                  \
    X(NewArr)               \
    X(LdLen)                \
    X(LdElem_A)             \
    X(LdElem_i1)            \
    X(LdElem_u1)            \
    X(LdElem_i2)            \
    X(LdElem_u2)            \
    X(LdElem_i4)            \
    X(LdElem_u4)            \
    X(LdElem_i8)            \
    X(LdElem_u8)            \
    X(LdElem_r4)            \
    X(LdElem_r8)            \
    X(LdElem_ref)           \
    X(StElem_i1)            \
    X(StElem_u1)            \
    X(StElem_i2)            \
    X(StElem_u2)            \
    X(StElem_i4)            \
    X(StElem_u4)            \
    X(StElem_i8)            \
    X(StElem_u8)            \
    X(StElem_r4)            \
    X(StElem_r8)            \
    X(StElem_ref)           \
    X(LdElem)               \
    X(StElem)               \
    X(UnboxAny)             \
    X(Print)                \

namespace rx {

enum class OpCode : u8 {
#define X(val) val,
    OPCODE_LIST(X)
#undef X
    _count,
    Invalid = 255
};

extern const char* g_opcode_str[(u32)OpCode::_count];

}